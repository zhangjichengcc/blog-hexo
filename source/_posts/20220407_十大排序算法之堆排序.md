---
title: 20220407_十大排序算法之堆排序
date: 2022-04-07 17:54:57
tags:
banner_img:
index_img:
categories:
---

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

<!-- more -->

> 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

## 预备知识

> 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：

![Heap](/images/posts/20211118_排序算法汇总/Heap.png)

同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子

![Heap Array](/images/posts/20211118_排序算法汇总/Heap1.png)

``` bash
      0
    /   \
   1     2          # 1 = 2*0+1    2 = 2*0+2
 /  \   /  \        
3    4 5    6       # 3 = 2*1+1    4 = 2*1+2    5 = 2*2+1    6 = 2*2+2

# leftChildIdx = 2 * parentIdx + 1
# rightChildIdx = 2 * parentIdx + 2
```

> 左右叶子节点

假设当前节点 `index = i` , 则:  

- 左叶子节点 `2 * index + 1`;

- 右叶子节点 `2 * index + 2`;  

> 最后一个非叶子节点

假设当前堆长度为n，则最后一个非叶子节点有两种情况：

1. 只有左叶子节点（此时列表长度为偶数）

    ``` bash
      lastNodeIdx = n-1 = 2 * lastUnLeftNodeIdx + 1;
                       
      lastUnLeftNodeIdx = (n - 2) / 2;
                        = n / 2 - 1;
    ```

2. 包含左右叶子节点（此时列表长度为奇数）

    ``` bash
      lastNodeIdx = n-1 = 2 * lastUnLeftNodeIdx + 2;

      lastUnLeftNodeIdx = (n - 3) / 2;
                        = (n - 1) / 2 - 1;
    ```

其中 `(n - 1) / 2` 可以通过 `Math.floor(n - 1)` 替代，根据上面公式可以推导出

``` bash
  lastUnLeftNodeIdx = Math.floor(n / 2) - 1; 
```

> 大顶堆 & 小顶堆

``` bash
#   大顶堆                小顶堆

      6                     0
    /   \                 /   \
   5     4               1     2
 /  \   /  \           /  \   /  \     
3    2 1    0         3    4 5    6
```

我们用简单的公式来描述一下堆的定义就是：

- 大顶堆：`arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]`

- 小顶堆：`arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]`

## 排序思想

![Heap Sort](/images/posts/20220407_堆排序/HeapSort.gif)

1. 构造大顶堆（一般升序采用大顶堆，降序采用小顶堆)；
2. 交换堆顶与最后一个叶子节点，此时数组最大值为最后一项；
3. 剩余未排序数组重复步骤 1、2 至整个数组有序；

![Heap Sort](/images/posts/20220407_堆排序/heap-sort.gif)

1. 构造初始堆。从最后一个 **非叶子节点** 开始，从右至左，从下到上处理，将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。
2. 交换堆顶与最后一个元素，将最大元素沉至数组末端
3. 从堆顶开始，重新构建大顶堆（第一步已经构建过大顶堆，所以）
4. 重复步骤2、3，至序列有序

## 代码实现

/**
 * 工具方法，以树结构打印数组
 * @param arr 
 */
function log(arr: number[]) {
  let _arr = JSON.parse(JSON.stringify(arr));
  let str = '', i = 1;
  while(_arr.length) {
    str += `${_arr.splice(0, i)}\n`;
    i = i * 2;
  }
  console.log(str);
}

/**
 * 生成单位大顶堆
 * @param arr 需要处理的数组
 * @param i 指定当前大顶堆根节点的idx
 * @param len 指定需要处理的数组范围（长度）
 */
function heaping(arr: number[], i: number, len: number) {
  let largestIdx = i;      // 设置最大值index, 默认当前i
  const leftIdx = 2*i+1, rightIdx = 2*i+2;
  if (leftIdx < len && arr[leftIdx] > arr[largestIdx]) largestIdx = leftIdx;
  if (rightIdx < len && arr[rightIdx] > arr[largestIdx]) largestIdx = rightIdx;
  if (largestIdx !== i) { // 最大值idx发生变化，则表示堆结构变化，更新largestIdx并回调验证堆
    // 将最大值移到堆顶
    [arr[largestIdx], arr[i]] = [arr[i], arr[largestIdx]];
    // 由于当前堆改变，将影响到对应子堆，
    heaping(arr, largestIdx, len);
  }
}

// 建立大顶堆
function buildMaxHeap(arr: number[]) {
  const len = arr.length;
  // Math.ceil(len / 2) - 1 为当前完全二叉树的最后一项非叶子节点
  for (let i = Math.ceil(len/2) - 1; i >= 0; i--) {
    heaping(arr, i, len);
  }
}

// // 排序
// function heapSort(arr: number[]) {
//   buildMaxHeap(arr);     // 首先建立大顶堆
//   log(arr);
//   let len = arr.length;  // 记录当前未排序数组长度
//   for(let i = arr.length - 1; i >= 0; i--) { // ? 注意，此处循环从 arr.length - 1 开始并非从子节点开始构建，而是用来记录当前未排序的元素下标
//     // 每次循环将最后一位（根据len变化）与堆顶元素交换位置，最大值始终插入最后（index = len）至数组有序
//     [arr[0], arr[len - 1]] = [arr[len - 1], arr[0]];
//     len --; // 每次操作完成，len减1
//     heaping(arr, 0, len);
//     log(arr);
//   }
//   return arr;
// }

/**
 * 排序 bad
 * @param arr 
 * @returns 
 */
function heapSort(arr: number[]) {
  log(arr);
  let len = arr.length;  // 记录当前未排序数组长度
  for(let i = arr.length - 1; i >= 0; i--) { // ? 注意，此处循环从 arr.length - 1 开始并非从子节点开始构建，而是用来记录当前未排序的元素下标
    // 重新构建大顶堆
    for (let j = Math.ceil(len/2) - 1; j >= 0; j--) {
      heaping(arr, j, len);
    }
    // 每次循环将最后一位（根据len变化）与堆顶元素交换位置，最大值始终插入最后（index = len）至数组有序
    [arr[0], arr[i]] = [arr[i], arr[0]];
    len --; // 每次操作完成，len减1
    log(arr);
  }
  return arr;
}

heapSort([2,9,3,1,4,5,6,7,8])


https://juejin.cn/post/6844903721856401416
