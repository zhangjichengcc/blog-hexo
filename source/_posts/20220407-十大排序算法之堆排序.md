---
title: 20220407_十大排序算法之堆排序
date: 2022-04-07 17:54:57
tags:
banner_img:
index_img:
categories:
---

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

<!-- more -->

> 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

## 预备知识

> 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：

![Heap](/images/posts/20211118_排序算法汇总/Heap.png)

同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子

![Heap Array](/images/posts/20211118_排序算法汇总/Heap1.png)

``` bash
      0
    /   \
   1     2          # 1 = 2*0+1    2 = 2*0+2
 /  \   /  \        
3    4 5    6       # 3 = 2*1+1    4 = 2*1+2    5 = 2*2+1    6 = 2*2+2

# leftChildIdx = 2 * parentIdx + 1
# rightChildIdx = 2 * parentIdx + 2
# lastUnLeafNodeIdx = Math.ceil(len / 2) - 1
```

假设当前节点 `index = i` , 则其左右叶子节点分别为 `2*index + 1; 2*index + 2`;
最后一个非叶子节点 `index = Math.ceil(len / 2) - 1`

该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：

- 大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]  

- 小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]  

## 排序思想

![Heap Sort](/images/posts/20211118_排序算法汇总/HeapSort.gif)

1. 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。
2. 从最后一个**非叶子节点**开始，从右至左，从下到上处理，构建大顶堆
3. 交换堆顶与最后一个元素，将最大元素沉至数组末端
4. 重复以上步骤，至序列有序

## 代码实现

``` js
/**
 * 处理子堆
 * arr: 待处理序列
 * i: 当前子堆堆顶index
 * len: 限制arr长度
 */
function heapify(arr, i, len) {
  let largestIdx = i;      // 设置最大值index, 默认当前i
  const leftIdx = 2*i+1, rightIdx = 2*i+2;
  if (leftIdx < len && arr[leftIdx] > arr[largestIdx]) largestIdx = leftIdx;
  if (rightIdx < len && arr[rightIdx] > arr[largestIdx]) largestIdx = rightIdx;
  if (largestIdx !== i) { // 最大值idx发生变化，则表示堆结构变化，更新largestIdx并回调验证堆
    // 将最大值移到堆顶
    [arr[largestIdx], arr[i]] = [arr[i], arr[largestIdx]];
    // 由于当前堆改变，将影响到对应子堆，
    heapify(arr, largestIdx, len);
  }
}

// 排序
function heapSort(arr) {
  let len = arr.length;
  // Math.ceil(len / 2) - 1 为当前完全二叉树的最后一项非叶子节点，每一个单位二叉树循环调用heapify()
  for(let i = Math.ceil(len / 2) - 1; i >= 0; i--) {
    heapify(arr, i, len);
    // 每次循环将最后一位（根据len变化）与堆顶元素交换位置，最大值始终插入最后（index = len）至数组有序
    [arr[0], arr[len - 1]] = [arr[len - 1], arr[0]];
    len --; // 每次操作完成，len减1
  }
  return arr;
}


var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量
 
function buildMaxHeap(arr) {   // 建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i >= 0; i--) {
        heapify(arr, i);
    }
}
 
function heapify(arr, i) {     // 堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;
 
    if (left < len && arr[left] > arr[largest]) {
        largest = left;
    }
 
    if (right < len && arr[right] > arr[largest]) {
        largest = right;
    }
 
    if (largest != i) {
        swap(arr, i, largest);
        heapify(arr, largest);
    }
}
 
function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
 
function heapSort(arr) {
    buildMaxHeap(arr);
 debugger
    for (var i = arr.length - 1; i > 0; i--) {
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    }
    return arr;
}
```
